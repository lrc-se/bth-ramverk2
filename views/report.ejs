<h1>Redovisningar</h1>
<p>Här följer redovisningarna som hör till kursen.</p>
<h3>Kursmoment:</h3>
<ul>
<% for(var i = 1; i <= 7; ++i) { -%>
    <%_ var x = (i < 7 ? "0" + i : 10); -%>
    <li><a href="#kmom<%= x %>">Kmom<%= x %></a>
<% } -%>
</ul>
<section id="kmom01">
    <h2>Kmom01</h2>
    <p>
        Bland det första jag gjorde, efter att ha <a href="https://dbwebb.se/forum/viewtopic.php?f=60&t=6979">erhållit tillstånd</a>, var att slänga ut Pug. 
        Det känns bara onödigt och framför allt <em>ineffektivt</em> att hålla på och lägga på ytterligare lager ovanpå existerande tekniker, med därtill hörande begränsningar, bara för sakens skull – 
        jag vill se vad jag gör och ha hela min verktygslåda till hands utan att behöva göra allehanda krumbukter för att komma åt den. 
        Hela tanken med s.k. "logiklösa mallar" är dessutom i mitt tycke fel i grunden: man bör visserligen inte ha <em>affärslogik</em> i sina vyer, 
        men det mesta utöver de mest basala tillämpningarna kommer att kräva <em>presentations&shy;logik</em> – och att då behöva flytta ut denna <em>från</em> 
        presentations&shy;lagret bara för att mallsystemet inte stöder den fullt ut är bara kontra&shy;produktivt och upphäver sitt eget syfte.
    </p>
    <p>
        Efter att ha gått igenom <a href="https://github.com/expressjs/express/wiki#template-engines">hela listan</a> på tillgängliga vymotorer föll mitt val slutligen på 
        <a href="http://ejs.co/">EJS</a>, mycket på grund av de anledningar som nämns på dess webbplats. Kort sagt, och återigen, 
        det finns ingen anledning att dra in (och behöva lära sig) ett helt nytt mallspråk som varken ser ut eller känns som HTML (t.ex. Pug/<wbr>HAML) 
        eller kontroll&shy;strukturer som varken ser ut eller känns som JavaScript (t.ex. Nunjucks/<wbr>Jinja2) – åtminstone inte i en kurs som använder sig av just HTML och JavaScript.
    </p>
    <p>
        Med EJS blir tvärtom allt hur enkelt som helst, särskilt i och med att man med Node har tillgång till förenkla(n)de ES6-konstruktioner, och det är bara att köra på. 
        Det finns dock en begränsning i att det saknas inbyggt stöd för layoutfiler, så jag byggde till ett eget minimalt system för detta, på likartat sätt som i <strong>ramverk1</strong> 
        (se vidare nedan). Vad gäller själva webbplatsen som sådan är stil&shy;sättningen den här gången avskalad och sparsam.
    </p>
    <p>
        Integrationen mot de externa tjänsterna gick lika smärtfritt som i den förra kursen. Jag valde Scrutinizer för kodkvalitets&shy;biten i och med att vi redan använt den där, 
        så får vi se om den duger fullt ut även här. Jag passade också på att introducera ett nytt validerings&shy;verktyg (<a href="https://www.npmjs.com/package/ejs-lint">ejs-lint</a>) 
        för EJS-mallarna, som nu ingår i min <code>make test</code>-svit. CSSLint och JSCS har dock fått stryka på foten och jag har gjort några smärre ingrepp i ESLints konfiguration.
    </p>
    <p>
        Slutligen har jag gjort försök med att köra applikationen publikt på studentservern (en av de två, i alla fall), vilket efter lite om och men verkar fungera. 
        Förut&shy;sättningen är att man (jag) kör <code>npm install</code> efter varje publicering för att återställa utvecklings&shy;miljön, 
        men det kanske man får ta; det är ju alltid trevligt att kunna visa upp det man gör och inte bara skriva om det.
    </p>
    <h5>Om Express och vymotorer</h5>
    <p>
        När det kommer till Express känns det mesta igen. Ett ramverk är ett ramverk och de ingående delarna är av nödvändighet likartade – 
        det finns ett begränsat antal sätt att lösa ett och samma problem på, oavsett plattform och teknik. Det som är specifikt i det här fallet är hur komponenterna samverkar och anropas, 
        vilket i sin tur känns igen från <strong>linux</strong>-kursen och Node-servrarna där, men det rör sig i grund och botten om samma beståndsdelar som används på samma sätt rent principiellt.
    </p>
    <p>
        Något som dock skiljer är hur man skapar och hanterar <em>middleware</em>-kedjor och sedan blir tonvikten på funktioner (och funktions&shy;objekt) 
        liksom det asynkrona upplägget större i och med att det rör sig om JS. Dessutom är ramverket här också sin egen webbserver, vilket inte är fallet med ramverk för t.ex. PHP eller ASP.NET, 
        som körs som tjänster i en separat webbserver&shy;applikation.
    </p>
    <p>
        Att Express också innehåller ett inbyggt (och tämligen enkelt) system för vyhantering är också positivt, 
        eftersom det gör det lätt att själv välja teknik enligt ovan utan att behöva ändra någonting i den anropande koden. Universella gränssnitt är bra, 
        även om det kanske kunde funnits fler (eller ens några) likaledes universella möjligheter att göra/<wbr>skicka med inställningar. 
        Sedan hade ju jag föredragit att man valt någon annan standard&shy;motor än just Jade/Pug, särskilt i och med att denna utgör ett sådant stort avsteg från både JS och HTML.
    </p>
    <h5>Berätta om din katalog&shy;struktur och hur du organiserade din kod. Hur tänkte du?</h5>
    <p>
        Mina statiska filer ligger i <i>static/</i> och mina vyer i <i>views/</i>. Vad gäller själva applikations&shy;koden har jag skapat en katalog <i>app/</i> 
        som för tillfället innehåller två filer: <i>app.js</i> och <i>util.js</i>. Den förstnämnda skapar och exporterar <code>app</code>-objektet medan den sistnämnda innehåller gemensamma funktioner 
        (just nu endast layout&shy;funktionen till EJS).
    </p>
    <p>
        I <i>routes/</i> ligger dels route&shy;hanterarna i egna filer (just nu endast en: <i>default.js</i>) och dels <i>routes.js</i> 
        som använder de övriga filerna för att konfigurera de olika sökvägarna utifrån valda grund&shy;sökvägar. Upplägget påminner en del om det i <strong>ramverk1</strong> 
        och det är <i>app/app.js</i> ovan som ansvarar för att kicka igång denna procedur (med lite DI-tänk).
    </p>
    <p>
        Min <i>index.js</i> är, slutligen, högst minimal och startar i princip bara servern. Samman&shy;fattningsvis är koden starkt modulariserad där varje del är begränsad i sitt omfång, 
        vilket alltså även inkluderar distributionen mellan katalogerna.
    </p>
    <h5>Använde du någon form av scaffolding som Express erbjuder?</h5>
    <p>
        Nej, men jag kikade lite på den genererade exempel&shy;koden och anammade/<wbr>anpassade vissa saker därifrån. 
        Här föredrog jag alltså att bygga en egen grund från början istället för att backa tillbaka från och modifiera en färdig struktur jag inte skulle varit fullt ut bekväm med, 
        vilket annars skulle blivit fallet.
    </p>
    <h5>Jobbar du med Markdown för innehållet, eller annat liknande?</h5>
    <p>
        Nej, jag tycker det mest är skönt att slippa ifrån det, då jag upplever det som alltför begränsande. Ge mig vanlig HTML alla dagar i veckan.
    </p>
</section>
<section id="kmom02">
    <h2>Kmom02</h2>
    <p>
        Jag insåg ganska snabbt att jag inte kunde köra varken Docker for Windows <em>eller</em> Docker Toolbox (ja, jag är säker), så jag började utforska andra sätt att komma vidare på. 
        Eftersom dokumentationen för Toolbox tydligt säger att det verktyget inkluderar VirtualBox, för att skapa en Linux-VM som kör Dockermotorn, som i sin tur kör behållaren som <em>i sin tur</em>
        kör det man egentligen vill köra, så tänkte jag att jag borde kunna använda min existerande Debian-VM i just VirtualBox från <b>linux</b>-kursen i våras direkt istället.
    </p>
    <p>
        Jag startade därför upp denna och följde instruktionerna för att installera Docker CE för Debian, vilket förlöpte väl. 
        Efter att ha installerat Docker Compose separat visade det sig sedan att allting faktiskt fungerade som det skulle, trots alla dessa upprepade abstraktioner – 
        det är som en rysk docka, eller Inception om man så vill. Sedan behövdes det en del hand&shy;påläggning för att få till de öppna portarna och synkningen med det ordinarie kursrepot, 
        men det var småsaker i jämförelse. Så nu kör jag Node i Linux i Docker i Linux i VirtualBox i Windows...
    </p>
    <p>
        PHP-behållarna i <i>kmom02/docker</i> använder version 5.6, 7.0 och 7.1 och det finns en <i>index.php</i> i samma katalog som kort och gott kör <code>phpinfo()</code>, 
        vilket gör det enkelt att bekräfta att det verkligen är rätt version som svarar. Node-behållarna kör version 4, 8 och 9, 
        där den förstnämnda av någon anledning är betydligt segare att både starta och avsluta, men alla tre fungerar bra. I båda fallen gäller att behållarna svarar på port 8101, 8102 respektive 8103.
    </p>
    <p>
        I övrigt har jag som flera andra uppdaterat repot (inklusive Travis-integrationen) till att använda <code>npm</code> istället för <code>make</code>, 
        vilket dock medförde att jag behövde lägga till <a href="https://www.npmjs.com/package/npm-run-all"><code>npm-run-all</code></a> 
        som ett beroende eftersom det annars inte går att få <code>npm</code> att köra flera skript i följd på ett sätt som fungerar konsekvent på både Windows (mitt system) och Linux 
        (dbwebb och de externa tjänsterna).
    </p>
    <p>
        Jag har lagt till skripten <code>htmlhint</code>, <code>stylelint</code>, <code>eslint</code> och <code>ejslint</code>, som motsvarar dem som tidigare kördes i makefilen, 
        samt ett samlande skript <code>lint</code> som kör dessa i följd (och inte avbryter exekveringen om ett av dem fallerar). Slutligen har jag uppdaterat <code>npm test</code> 
        som för närvarande bara kör just <code>npm run lint</code>, men tanken är att det skall in fler steg i den sekvensen vad det lider.
    </p>
    <h5>Har du jobbat med Docker eller andra virtuali&shy;serings&shy;tekniker innan?</h5>
    <p>
        Docker är nytt, men jag har tidigare använt VirtualBox för flera olika gäst-OS, så konceptet som sådant är jag bekant med.
    </p>
    <h5>Hur ser du på möjligheterna att använda dig av Docker för att jobba med test av ditt repo?</h5>
    <p>
        Ärligt talat känns det mest som en massa onödigt krångel, särskilt eftersom vi/jag (åtminstone så långt) inte har något reellt behov av att köra flera parallella versioner. 
        Det blir bara lager på lager på lager och det är symptomatiskt att även det <em>officiella</em> sättet att köra Docker på allt annat än de senaste versionerna av Windows och MacOS 
        (med Docker Toolbox) innebär virtualisering i flera steg, vilket knappast (läs: definitivt inte) är resurs&shy;effektivt någonstans.
    </p>
    <p>
        Så nej, jag är inte särskilt imponerad så långt (annat än av att det över huvud taget fungerar) och har svårt att se nyttan i det här fallet. Kanske det kommer? 
        Annars känns det mest som ännu ett i en lång rad av påbjudna saker som egentligen är gjorda för Unix/Linux och bara med nöd och näppe går att tvinga in på andra plattformar. 
        Dbwebbs redan kraftiga slagsida åt vad som anses som <em>rätt och riktigt</em> blir allt tydligare...
    </p>
    <h5>Gick allt smidigt eller stötte du på problem?</h5>
    <p>
        Det största problemet var alltså att jag inte kunde installera Docker över huvud taget på vanligt sätt, men den alternativa vägen som beskrivs ovan fungerade oväntat bra – 
        faktiskt har allt fungerat felfritt från första stund. Uppenbarligen ligger det en hel del arbete bakom dessa verktyg, 
        även om det kanske inte egentligen är meningen att de skall användas på just det här sättet.
    </p>
    <p>
        Det enda lilla hindret jag stötte på var att <a href="https://github.com/nodejs/docker-node/blob/master/README.md#how-to-use-this-image">den officiella dokumentationen</a> 
        för hur man skulle konfigurera <code>docker-node</code> med Docker Composer inte fungerade – servern gick inte att nå utifrån – 
        så jag ändrade lite i formatet i konfigfilen för att bättre överens&shy;stämma med det i 
        <a href="https://dbwebb.se/kunskap/kom-igang-med-docker-som-utvecklingsmiljo#docker-compose">dbwebb-exemplet</a> istället, 
        som jag redan visste lirade med PHP. Efter det fungerade allt som det skulle.
    </p>
    <h5>Skapade du din egen image? Berätta om den.</h5>
    <p>
        Nej, det kändes inte motiverat i det här skedet – och särskilt inte att <em>publicera</em> någonting som bara är menat som ett test. 
        Jag är för övrigt fortsatt starkt emot krav som innebär just krav på att registrera sig hos tjänster man inte själv valt och 
        att där göra saker publikt tillgängliga som man själv inte tycker borde vara det.
    </p>
</section>
<section id="kmom03">
    <h2>Kmom03</h2>
    <p>blubb</p>
</section>
<section id="kmom04">
    <h2>Kmom04</h2>
    <p>blubb</p>
</section>
<section id="kmom05">
    <h2>Kmom05</h2>
    <p>blubb</p>
</section>
<section id="kmom06">
    <h2>Kmom06</h2>
    <p>blubb</p>
</section>
<section id="kmom10">
    <h2>Kmom10</h2>
    <p>blubb</p>
</section>
