<h1>Redovisningar</h1>
<p>Här följer redovisningarna som hör till kursen.</p>
<h3>Kursmoment:</h3>
<ul>
<% for(var i = 1; i <= 7; ++i) { -%>
    <%_ var x = (i < 7 ? "0" + i : 10); -%>
    <li><a href="#kmom<%= x %>">Kmom<%= x %></a>
<% } -%>
</ul>
<section id="kmom01">
    <h2>Kmom01</h2>
    <p>
        Bland det första jag gjorde, efter att ha <a href="https://dbwebb.se/forum/viewtopic.php?f=60&amp;t=6979">erhållit tillstånd</a>, var att slänga ut Pug. 
        Det känns bara onödigt och framför allt <em>ineffektivt</em> att hålla på och lägga på ytterligare lager ovanpå existerande tekniker, med därtill hörande begränsningar, bara för sakens skull – 
        jag vill se vad jag gör och ha hela min verktygslåda till hands utan att behöva göra allehanda krumbukter för att komma åt den. 
        Hela tanken med s.k. "logiklösa mallar" är dessutom i mitt tycke fel i grunden: man bör visserligen inte ha <em>affärslogik</em> i sina vyer, 
        men det mesta utöver de mest basala tillämpningarna kommer att kräva <em>presentations&shy;logik</em> – och att då behöva flytta ut denna <em>från</em> 
        presentations&shy;lagret bara för att mallsystemet inte stöder den fullt ut är bara kontra&shy;produktivt och upphäver sitt eget syfte.
    </p>
    <p>
        Efter att ha gått igenom <a href="https://github.com/expressjs/express/wiki#template-engines">hela listan</a> på tillgängliga vymotorer föll mitt val slutligen på 
        <a href="http://ejs.co/">EJS</a>, mycket på grund av de anledningar som nämns på dess webbplats. Kort sagt, och återigen, 
        det finns ingen anledning att dra in (och behöva lära sig) ett helt nytt mallspråk som varken ser ut eller känns som HTML (t.ex. Pug/<wbr>HAML) 
        eller kontroll&shy;strukturer som varken ser ut eller känns som JavaScript (t.ex. Nunjucks/<wbr>Jinja2) – åtminstone inte i en kurs som använder sig av just HTML och JavaScript.
    </p>
    <p>
        Med EJS blir tvärtom allt hur enkelt som helst, särskilt i och med att man med Node har tillgång till förenkla(n)de ES6-konstruktioner, och det är bara att köra på. 
        Det finns dock en begränsning i att det saknas inbyggt stöd för layoutfiler, så jag byggde till ett eget minimalt system för detta, på likartat sätt som i <strong>ramverk1</strong> 
        (se vidare nedan). Vad gäller själva webbplatsen som sådan är stil&shy;sättningen den här gången avskalad och sparsam.
    </p>
    <p>
        Integrationen mot de externa tjänsterna gick lika smärtfritt som i den förra kursen. Jag valde Scrutinizer för kodkvalitets&shy;biten i och med att vi redan använt den där, 
        så får vi se om den duger fullt ut även här. Jag passade också på att introducera ett nytt validerings&shy;verktyg (<a href="https://www.npmjs.com/package/ejs-lint">ejs-lint</a>) 
        för EJS-mallarna, som nu ingår i min <code>make test</code>-svit. CSSLint och JSCS har dock fått stryka på foten och jag har gjort några smärre ingrepp i ESLints konfiguration.
    </p>
    <p>
        Slutligen har jag gjort försök med att köra applikationen publikt på studentservern (en av de två, i alla fall), vilket efter lite om och men verkar fungera. 
        Förut&shy;sättningen är att man (jag) kör <code>npm install</code> efter varje publicering för att återställa utvecklings&shy;miljön, 
        men det kanske man får ta; det är ju alltid trevligt att kunna visa upp det man gör och inte bara skriva om det.
    </p>
    <h5>Om Express och vymotorer</h5>
    <p>
        När det kommer till Express känns det mesta igen. Ett ramverk är ett ramverk och de ingående delarna är av nödvändighet likartade – 
        det finns ett begränsat antal sätt att lösa ett och samma problem på, oavsett plattform och teknik. Det som är specifikt i det här fallet är hur komponenterna samverkar och anropas, 
        vilket i sin tur känns igen från <strong>linux</strong>-kursen och Node-servrarna där, men det rör sig i grund och botten om samma beståndsdelar som används på samma sätt rent principiellt.
    </p>
    <p>
        Något som dock skiljer är hur man skapar och hanterar <em>middleware</em>-kedjor och sedan blir tonvikten på funktioner (och funktions&shy;objekt) 
        liksom det asynkrona upplägget större i och med att det rör sig om JS. Dessutom är ramverket här också sin egen webbserver, vilket inte är fallet med ramverk för t.ex. PHP eller ASP.NET, 
        som körs som tjänster i en separat webbserver&shy;applikation.
    </p>
    <p>
        Att Express också innehåller ett inbyggt (och tämligen enkelt) system för vyhantering är också positivt, 
        eftersom det gör det lätt att själv välja teknik enligt ovan utan att behöva ändra någonting i den anropande koden. Universella gränssnitt är bra, 
        även om det kanske kunde funnits fler (eller ens några) likaledes universella möjligheter att göra/<wbr>skicka med inställningar. 
        Sedan hade ju jag föredragit att man valt någon annan standard&shy;motor än just Jade/Pug, särskilt i och med att denna utgör ett sådant stort avsteg från både JS och HTML.
    </p>
    <h5>Berätta om din katalog&shy;struktur och hur du organiserade din kod. Hur tänkte du?</h5>
    <p>
        Mina statiska filer ligger i <i>static/</i> och mina vyer i <i>views/</i>. Vad gäller själva applikations&shy;koden har jag skapat en katalog <i>app/</i> 
        som för tillfället innehåller två filer: <i>app.js</i> och <i>util.js</i>. Den förstnämnda skapar och exporterar <code>app</code>-objektet medan den sistnämnda innehåller gemensamma funktioner 
        (just nu endast layout&shy;funktionen till EJS).
    </p>
    <p>
        I <i>routes/</i> ligger dels route&shy;hanterarna i egna filer (just nu endast en: <i>default.js</i>) och dels <i>routes.js</i> 
        som använder de övriga filerna för att konfigurera de olika sökvägarna utifrån valda grund&shy;sökvägar. Upplägget påminner en del om det i <strong>ramverk1</strong> 
        och det är <i>app/app.js</i> ovan som ansvarar för att kicka igång denna procedur (med lite DI-tänk).
    </p>
    <p>
        Min <i>index.js</i> är, slutligen, högst minimal och startar i princip bara servern. Samman&shy;fattningsvis är koden starkt modulariserad där varje del är begränsad i sitt omfång, 
        vilket alltså även inkluderar distributionen mellan katalogerna.
    </p>
    <h5>Använde du någon form av scaffolding som Express erbjuder?</h5>
    <p>
        Nej, men jag kikade lite på den genererade exempel&shy;koden och anammade/<wbr>anpassade vissa saker därifrån. 
        Här föredrog jag alltså att bygga en egen grund från början istället för att backa tillbaka från och modifiera en färdig struktur jag inte skulle varit fullt ut bekväm med, 
        vilket annars skulle blivit fallet.
    </p>
    <h5>Jobbar du med Markdown för innehållet, eller annat liknande?</h5>
    <p>
        Nej, jag tycker det mest är skönt att slippa ifrån det, då jag upplever det som alltför begränsande. Ge mig vanlig HTML alla dagar i veckan.
    </p>
</section>
<section id="kmom02">
    <h2>Kmom02</h2>
    <p>
        Jag insåg ganska snabbt att jag inte kunde köra varken Docker for Windows <em>eller</em> Docker Toolbox (ja, jag är säker), så jag började utforska andra sätt att komma vidare på. 
        Eftersom dokumentationen för Toolbox tydligt säger att det verktyget inkluderar VirtualBox, för att skapa en Linux-VM som kör Docker&shy;motorn, som i sin tur kör behållaren som 
        <em>i sin tur</em> kör det man egentligen vill köra, så tänkte jag att jag borde kunna använda min existerande Debian-VM i just VirtualBox från <b>linux</b>-kursen i våras direkt istället.
    </p>
    <p>
        Jag startade därför upp denna och följde instruktionerna för att installera Docker CE för Debian, vilket förlöpte väl. 
        Efter att sedan ha installerat Docker Compose separat visade det sig att allting faktiskt fungerade som det skulle, trots alla dessa upprepade abstraktioner – 
        det är som en rysk docka, eller <i>Inception</i> om man så vill. Sedan behövdes det en del hand&shy;påläggning för att få till de öppna portarna och synkningen med det ordinarie kursrepot, 
        men det var småsaker i jämförelse. Så nu kör jag Node i Linux i Docker i Linux i VirtualBox i Windows...
    </p>
    <p>
        PHP-behållarna i <i>kmom02/docker</i> använder version 5.6, 7.0 och 7.1 och det finns en <i>index.php</i> i samma katalog som kort och gott kör <code>phpinfo()</code>, 
        vilket gör det enkelt att bekräfta att det verkligen är rätt version som svarar. Node-behållarna kör version 4, 8 och 9, 
        där den förstnämnda av någon anledning är betydligt segare att både starta och avsluta, men alla tre fungerar bra. Jag tog även bort den föreslagna miljö&shy;variabeln, 
        så att Node fortsatt kör i utvecklings&shy;läge för att fel&shy;meddelanden skall framgå. För båda momenten gäller att behållarna svarar på port 8101, 8102 respektive 8103.
    </p>
    <p>
        I övrigt har jag som flera andra uppdaterat repot (inklusive Travis-integrationen) till att använda <code>npm</code> istället för <code>make</code>, 
        vilket dock medförde att jag behövde lägga till <a href="https://www.npmjs.com/package/npm-run-all"><code>npm-run-all</code></a> 
        som ett beroende eftersom det annars inte går att få <code>npm</code> att köra flera skript i följd på ett sätt som fungerar konsekvent på både Windows (mitt system) och Linux 
        (dbwebb och de externa tjänsterna).
    </p>
    <p>
        Jag har lagt till skripten <code>htmlhint</code>, <code>stylelint</code>, <code>eslint</code> och <code>ejslint</code>, som motsvarar dem som tidigare kördes i makefilen, 
        samt ett samlande skript <code>lint</code> som kör dessa i följd (och inte avbryter exekveringen om ett av dem fallerar). Slutligen har jag uppdaterat <code>npm test</code> 
        som för närvarande bara kör just <code>npm run lint</code>, men tanken är att det skall in fler steg i den sekvensen vad det lider.
    </p>
    <h5>Har du jobbat med Docker eller andra virtuali&shy;serings&shy;tekniker innan?</h5>
    <p>
        Docker är nytt, men jag har tidigare använt VirtualBox för flera olika gäst-OS, så konceptet som sådant är jag bekant med.
    </p>
    <h5>Hur ser du på möjligheterna att använda dig av Docker för att jobba med test av ditt repo?</h5>
    <p>
        Ärligt talat känns det mest som en massa onödigt krångel, särskilt eftersom vi/jag (åtminstone så långt) inte har något reellt behov av att köra flera parallella versioner. 
        Det blir bara lager på lager på lager och det är symptomatiskt att även det <em>officiella</em> sättet att köra Docker på allt annat än de senaste versionerna av Windows och MacOS 
        (med Docker Toolbox) innebär virtualisering i flera steg, vilket knappast (läs: definitivt inte) är resurs&shy;effektivt någonstans.
    </p>
    <p>
        Så nej, jag är inte särskilt imponerad så långt (annat än av att det över huvud taget fungerar) och har svårt att se nyttan i det här fallet. Kanske det kommer? 
        Annars känns det mest som ännu ett i en lång rad av påbjudna saker som egentligen är gjorda för Unix/Linux och bara med nöd och näppe går att tvinga in på andra plattformar. 
        Dbwebbs redan kraftiga slagsida ifråga om vad som anses som <em>rätt och riktigt</em> blir allt tydligare...
    </p>
    <h5>Gick allt smidigt eller stötte du på problem?</h5>
    <p>
        Det största problemet var alltså att jag inte kunde installera Docker över huvud taget på vanligt sätt, men den alternativa vägen som beskrivs ovan fungerade oväntat bra – 
        faktiskt har allt fungerat felfritt från första stund. Uppenbarligen ligger det en hel del arbete bakom dessa verktyg, 
        även om det kanske inte egentligen är meningen att de skall användas på just det här sättet.
    </p>
    <p>
        Det enda lilla hindret jag stötte på var att <a href="https://github.com/nodejs/docker-node/blob/master/README.md#how-to-use-this-image">den officiella dokumentationen</a> 
        för hur man skulle konfigurera <code>docker-node</code> med Docker Compose inte fungerade – servern gick inte att nå utifrån – 
        så jag ändrade lite i formatet i konfigfilen för att bättre överens&shy;stämma med det i 
        <a href="https://dbwebb.se/kunskap/kom-igang-med-docker-som-utvecklingsmiljo#docker-compose">dbwebb-exemplet</a> istället, 
        som jag redan visste lirade med PHP. Efter det fungerade allt som det skulle.
    </p>
    <h5>Skapade du din egen image? Berätta om den.</h5>
    <p>
        Nej, det kändes inte motiverat i det här skedet – och särskilt inte att <em>publicera</em> någonting som bara är menat som ett test. 
        Jag är för övrigt fortsatt starkt emot krav som innebär just krav på att registrera sig hos tjänster man inte själv valt och 
        att där göra saker publikt tillgängliga som man själv inte tycker borde vara det.
    </p>
</section>
<section id="kmom03">
    <h2>Kmom03</h2>
    <p>
        Både redovisa-repot och applikationen använder <code>npm</code> istället för <code>make</code> fullt ut – den senare har inte ens någon makefil. 
        I båda fallen kör kommandot <code>npm test</code> först validatorerna och därefter enhetstesten, så vill man endast köra de sistnämnda är det <code>npm run tap</code> 
        som gäller istället (se vidare nedan). Jag har även passat på att städa en del i beroendena i och med att jag använder andra (och färre) verktyg än i standard&shy;utförandet av 
        kursen/<wbr>uppgifterna; <i>node_modules</i> är <a href="https://pbs.twimg.com/media/C3SOI-_WAAAM4Js.jpg">omfattande nog</a> som den är, så det är bara bra om det går att kapa bort saker där.
    </p>
    <p>
        Me-sidan har fått ett enkelt testfall bara för att se att det hela fungerar, men det känns mest konstlat och har inget egentligt värde då funktionen ifråga inte är att betrakta som allmän.
    </p>
    <h5>Berätta vilka tekniker/<wbr>verktyg du valde för enhetstest och kodtäckning och varför.</h5>
    <p>
        Som testverktyg valde jag <a href="http://www.node-tap.org/">Node Tap</a> för att det helt enkelt <em>kändes</em> bäst. 
        Verktygets skapare uttrycker dessa känslor väl på dess startsida, så istället för att upprepa allt ordagrant här hänvisar jag helt enkelt dit och säger <strong>+1</strong>, 
        men det här citatet är värt att lyfta fram:
    </p>
    <blockquote>JavaScript tests should be JavaScript programs; not English-language poems with weird punctuation.</blockquote>
    <p>
        Kodtäckningen sköts av <a href="https://www.npmjs.com/package/nyc">nyc</a> (Istanbul), som Node Tap inkluderar per standard, så det var bara att köra på. 
        Denna kombination kan även enkelt generera en Clover-rapport som Scrutinizer kan tolka, 
        så jag behövde inte dra in någon ytterligare tjänst utan kunde bara snickra ihop en passande konfigurations&shy;fil – och som vanligt gick allt igenom på första försöket.
    </p>
    <p>
        Något annat som är positivt är att det trots att mycket annat sägs i diverse manualer går alldeles utmärkt att köra och testa ES6-kod utan vidare med dessa verktyg, 
        så Babel göra sig icke besvär! En liten nackdel med Node Tap är att dokumentationen är rätt så sparsam, så det tog ett tag att klura ut hur jag skulle använda <code>beforeEach()</code>, 
        men testfallen för applikationen (se nedan) blev enklare och renare när detta väl var på plats. Jag gjorde även en egen liten modul&shy;laddare för att kringgå <code>require</code>-cachen, 
        så att man får en ny instans av modulen ifråga för varje deltest för att säkerställa isolation.
    </p>
    <h5>Berätta om din CI-kedja och reflektera över de val du gjorde.</h5>
    <p>
        Jag vet inte om det är så mycket att berätta, då den som sagt ser likadan ut som förut – och som i <b>ramverk1</b>. Det är bara konfigurations&shy;filerna som skiljer sig en del, 
        men funktions&shy;mässigt är det likvärdigt – och allt fortsätter att förlöpa finfint, utan problem i vare sig automatik eller exekvering. 
        Men för att upprepa använder jag alltså <a href="https://travis-ci.org/">Travis CI</a> som byggtjänst och <a href="http://scrutinizer-ci.com/">Scrutinizer</a> 
        för kodkvalitet och kodtäckning, vilket synes mig fullt tillräckligt.
    </p>
    <h5>Reflektera över hur det gick att integrera enhetstesten i olika Docker&shy;behållare och om du ser någon nytta med detta.</h5>
    <p>
        Detta var lite knivigare än sist då både dokumentationen och instruktionerna lämnar en del att önska, så det blev mycket exempel&shy;studier och <i>trial and error</i>. 
        I slutändan, efter många felsteg, gjorde jag så att varje behållare (jag har tre: senaste Node, Node 8 och Node 4) kör ett shellskript som först skriver ut Node&shy;versionen, 
        så att man säkert vet vilken miljö man befinner sig i, och sedan kör <code>npm test</code>.
    </p>
    <p>
        Rent tekniskt baseras mina behållare på <code>node:alpine</code> för att inte slösa så vansinnigt med diskutrymme och jag har lagt konfigurationen för Docker Compose i en egen fil 
        (<i>docker-compose-test.yml</i>) för att inte inkräkta på de tidigare behållarna som startar servern. Test&shy;behållarna startas med <code>npm run test1</code> o.s.v. 
        Jag har även gjort ett medvetet val att <em>inte</em> köra <code>npm install</code> inne i behållaren, utan förlitar mig på att detta gjorts i huvud&shy;katalogen först – 
        det känns bara dumt, slösaktigt och ineffektivt att duplicera detta monster hela <em>fyra</em> gånger i onödan. Det finns ju redan beroenden till huvud&shy;katalogen i form av källkoden, 
        så en sådan redundans känns inte motiverad här.
    </p>
    <p>
        Vad gäller användnings&shy;områden så inser jag nyttan av att kunna testa saker mot olika målmiljöer utan att behöva byta maskin, 
        men i ett större perspektiv ser jag faror med att bygga hela sin utvecklings- och, ännu värre, produktions&shy;miljö kring Docker. 
        Eftersom varje behållare är självständig och innehåller <em>hela</em> den stack den behöver blir det i slutändan ett oerhört ineffektivt utnyttjande av resurser – 
        vem skulle medvetet välja att köra tiotals olika instanser av <em>samma</em> operativ&shy;system, inklusive allt, i något annat sammanhang om man inte behöver det? – 
        och diskutrymmet försvinner i rasande takt. Någonstans måste man sansa sig också och inte se allt som spikar bara för att man hittat en hammare.
    </p>
    <h5>Hur väl lyckades du utvärdera TDD-konceptet och vilka är dina reflektioner?</h5>
    <p>
        Jag gjorde ett allvarligt försök att följa detta för ordliste&shy;modulen i applikationen (se nedan), men kunde förstås inte låta bli att <em>tänka</em> på hur koden skulle se ut i förväg. 
        Det känns helt bakvänt att jobba på det sättet – vilket det också är – och jag trivs inte alls med det. Den utbredda evangelismen – den absoluta tron på att man har hittat 
        <em>Den Sanna Vägen</em> och att alla andra synsätt är fundamentalt fel – bland metodens förespråkare verkar också frånstötande.
    </p>
    <p>
        Det finns gott om kritiska TDD-artiklar på nätet, många baserade på konkreta erfarenheter, och jag behöver inte upprepa alla invändningar här, 
        men en fallgrop jag ser som extra tydlig och allvarlig är att man riskerar – eller kanske t.o.m. <em>garanterat kommer</em> – att få ett för smalt fokus och tappar greppet om helheten, 
        vilket gör att system&shy;arkitekturen på högre nivå blir lidande. TDD uppmuntrar till att lösa ett problem (ett fallerande test) på enklast/<wbr>minsta möjliga sätt, 
        vilket kanske fungerar i sammanhanget av den testade <em>enheten</em> men inte nödvändigtvis är lämpligt i sammanhanget av det större <em>systemet</em>, 
        där det kan finnas andra parametrar att beakta – särskilt om man underlåter (eller helt enkelt glömmer) att refaktorisera och städa upp efter de inledande stegen.
    </p>
    <p>
        Det blir även ett orimligt stort fokus på och beroende av testfallen, vilket kan leda till skör och ofullständig kod om man inte ser upp – 
        bara för att koden passerar testen och kod&shy;täckningen ligger på 100&nbsp;% betyder det inte nödvändigtvis att den faktiskt gör det den skall i produktion, med fysiska användare. 
        Kort sagt, koden blir bara så bra som testfallen är och det är i de allra flesta fall <em>omöjligt</em> att täcka in <em>samtliga</em> 
        kombinationer av tillstånd som ett system kan uppnå under körning, även om alla kodgrenar berörs.
    </p>
    <p>
        Ett typexempel är PHP-funktionen <a href="http://php.net/manual/en/function.empty.php"><code>empty()</code></a>, 
        som om den används för att kolla efter saknade indata kommer att stå för en obehaglig överraskning den dag någon skriver in strängen <code>"0"</code> – 
        och har testfallen inte fångat detta under utvecklingen är koden fortfarande felaktig i grunden, oavsett vad test&shy;rapporterna visar.
    </p>
    <p>
        Det finns också en tydlig risk i att skriva sina egna test, eftersom eventuella missar och förbiseenden ifråga om specifika&shy;tionerna och funktionali&shy;teten 
        då även kommer att hamna i systemet – testen och koden delar av nödvändighet samma svaghet i dessa fall och det faktum att testfallen passerar ger då en falsk säkerhet. 
        Ur en rent praktisk synvinkel är det även knepigt att fullt ut upprätthålla mantrat att skriva testet först, eftersom detta ju måste ha något att testa, 
        oavsett om det fallerar eller inte. Därmed måste man även i många fall skriva tillfällig kod för att över huvud taget kunna köra testsviten, 
        så det blir en hel del fram-och-tillbaka ändå. 
    </p>
    <p>
        Så, för att sammanfatta: Tack, men nej tack.
    </p>
    <h5>Berätta om tankarna kring din klient/server-applikation och nämn de tekniker du använder.</h5>
    <p>
        Det här var den del av momentet som var överlägset knepigast och tog längst tid – innan jag ens hade skrivit en enda kodrad. 
        Jag har luftat svårigheterna i <a href="https://dbwebb.se/forum/viewtopic.php?f=60&amp;t=7005">forumet</a> och har efter responsen slutligen landat i någon form av plan.
    </p>
    <p>
        Jag har tidigare, i en annan kurs på ett annat lärosäte, med en annan plattform och på ett annat sätt (skrivbords&shy;applikation i Java), utvecklat en variant av spelet <i>Skissa & Gissa</i>, 
        som de något äldre (hrrm) bland oss kanske kommer ihåg från den gamla portalen Passagens storhetstid kring millennie&shy;skiftet – 
        det var många håltimmar som gick åt till detta när det begav sig. Efter att ha tjuvkikat på Kmom04 och de realtids&shy;möjligheter som detta erbjuder 
        (nån fördel skall man väl ha av att skjuta upp saker och ting) bestämde jag mig för att försöka åter&shy;implementera detta inom ramarna för denna kurs. 
        Se även <a href="/app">applikations&shy;sidan</a>.
    </p>
    <p>
        Efter att ha gått igenom koden för den gamla applikationen och filtrerat den genom ökad erfarenhet samt kunskap om de verktyg vi har att tillgå här ser jag betydande potential till 
        både förbättring och färdighets&shy;mässig utveckling – JavaScripts inbyggda asynkronism förenklar mycket och <i>Web Sockets</i> tillsammans med JSON ser trevligt ut. 
        Eftersom det av nödvändighet handlar om grafisk framställning ger upplägget också möjlighet att dyka ner i <code>&lt;canvas&gt;</code>-världen 
        samt erbjuder ett betydligt bättre och mer <i>passande</i> tillfälle att testa ett ordentligt SPA-/<wbr>frontend&shy;ramverk än vad me-sidan gör.
    </p>
    <p>
        Exakt hur jag gör är ännu öppet, då alla bitar inte är på plats ännu, men tanken är alltså att knåpa på så smått med under&shy;stödjande tekniker under de ordinarie kurs&shy;momenten 
        och sedan övergå till att bygga själva applikationen på allvar när vi går in i projektet – 
        och det var just insikten om att detta är tillåtet som gjorde att jag kände att jag kunde ta steget och slå in på den här vägen. Vi får se hur långt det håller...
    </p>
    <p>
        Applikationen är (eller kommer att bli) uppdelad i två repon – ett för klienten och ett för servern – där det sistnämnda just nu endast innehåller en enkel komponent som hanterar ordlistan, 
        vilket var det bästa jag kunde komma på att bryta ut för att testa så här inledningsvis.
    </p>
</section>
<section id="kmom04">
    <h2>Kmom04</h2>
    <p>blubb</p>
</section>
<section id="kmom05">
    <h2>Kmom05</h2>
    <p>blubb</p>
</section>
<section id="kmom06">
    <h2>Kmom06</h2>
    <p>blubb</p>
</section>
<section id="kmom10">
    <h2>Kmom10</h2>
    <p>blubb</p>
</section>
